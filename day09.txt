메소드
	이름 뒤에 소괄호
	어떠한 기능을 한다.
	코드를 재사용하기 위해서 사용한다.

메소드의 정의
	클래스 안쪽, 메인 메소드 바깥쪽에 정의한다.

	public static 반환타입 메소드명(매개변수){
		코드;
		코드;
		.....

	}

메소드를 사용(호출)
	클래스명.메소드명();
	ex) Integer.parseInt();
		System.out.println();

메소드는 매개변수가 있을 수도 있고 없을 수도 있따.
만약 메소드를 만들때 사용해야하는 값을 메소드를 사용하는 사람으로 부터
전달 받고 싶다면 매개변수를 설정할 수 있고, 
메소드를 사용하는 사람은 매개변수를 넘겨주어야지 메소드를 사용할 수 있다.

메소드는 return값이 있을수도 있고, 없을 수도 있다.
	만약 메소드를 사용한 결과를 값처럼 활용하고 싶다면
	return값을 설정하여 값으로 되돌려주면 된다.
	이때, 리턴타입 자리에는 리턴된 값의 타입을 써 주어야 한다.
	메소드 사용자는 값으로 되돌려 받았기 떄문에
	메소드의 사용 결과를 변수에 저장하거나 추가적인 연산이 가능하다.


-------------------------------------------------------------------------
메소드 오버로딩(over  loading)

	같은 이름의 메소도를 매개변수 타입 혹은 갯수를 다르게 하여  정의하는 행위
	(리턴 타입이나 매개변수 이름과는 무관하다.)

---------------------------------------------------------------------------

변수의 생명주기
	같은 영역에서 같은 이름의 변수는 생성 할 수 없다.

지역변수(local variable)
	해당 영역(지역)내부에서만 사용할 수 있는 변수
	->메소드 안에 선언된 변수

	->메소드가 호출되면 메모리에 할당되고, 메소드 호출이 동료되면 메모리에서 해제

	매소드의 매개변수나 지역변수는 해당 메소드 안에서 밖에 사용할 수 없다.
	인자(매개변수로 넘겨받은 과정)로 넘겨받는 값을 잠시 복사하여 해당 메소드 영역 안에서 사용하다가
	메소드 사용이 끝나면 매개변수는 메모리에서 해제된다.

	값을 복사하여 사용하고 다시 값으로 되돌려주는 방식으로 해석

--------------------------------------------------------------------------
객체 지향 언어
	:현실에 존재하는 사물과 개념들을 소프트웨어적으로 구현하고,
		그 구현된 객체들이 상호작용하여 데이터를 처리하는 방식

	특징
		1.코드의 재사용성: 새로운 코드를 작성할 떄, 기존의 코드를 이용
				>>코드의 수를 줄일 수 있고, 유지 보수하기에도 편리하다.

		2.신뢰성 높은 프로그래밍: 제어자와 메소드를 사용해서 데이터를 보호한다.
				코드의 중복을 제거하여 오동작을 방지한다.

		3.코드 관리의 편리함: 객체지향 프로그래밍은 한 부분만 변경하면
				관련된 모든 부분이 변경된다. 따라서 코드의 관리가 편리하다.


클래스(class)
	객체를 만들기 위해서는 객체의 설계도가 필요
	클래스가 객체의 설계도 역할
	클래스에는 객체의 속성과 기능들이 정의 되어있고, 이를 통해서 객체를 생성한다.

	사용자가 만드는 새로운 유형의 자료형(type)이라고 이해해보자
	(여러가지 타입의 값을 한번에 저장할 수 있는 확장된 배열 개념)
		>>배열도 들어갈 수 있고, 메소드도 담을 수 있다.

인스턴스(instance)
	: 인스턴스는 클래스를 통해 만들어진 형태
	클래스가 객체의 설계도라면 설계도를 통해 실질적으로 만들어진 형태가 인스턴스이다.

클래스를 선언(정의)

	class 클래스_이름{

	}

생성자
	클래스 이름()
	메모리에  객체를 등록시켜주는 기능이 정해져있다.
	return을 사용할 수 없고, 생성자라고 부른다.

	생성자를 정의한 것이 없다면 컴퓨터가 기본 생성자를 추가해준다.
	만일 생성자를 직접 정의한 것이 있다면 기본 생성자를 추가해주지 않는다.

